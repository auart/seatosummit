<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sea to Summit, Wake Up Look Around</title>

<style>
  html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
  }

  /* full screen stage */
  .app {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: center;
    background: #000;
  }

  /* keeps your artwork crisp */
  img {
    image-rendering: pixelated;
    -webkit-user-drag: none;
    user-select: none;
  }

  /* scene container, change these if your art isn't 1200x675 */
  .scene {
    position: relative;
    width: 1200px;
    height: 675px;
    overflow: hidden;
  }

  /* the "camera" only affects the world layer, not UI */
  .world {
    position: absolute;
    inset: 0;
    transform: translate(0px, 0px);
    will-change: transform, filter, opacity;
  }

  .world img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  /* base look */
  .base { opacity: 1; }
  .water { opacity: 1; }
  .palms { opacity: 1; }

  /* optional loop anims you had, still here */
  .water {
    animation: waveShift 2.8s ease-in-out infinite;
  }
  @keyframes waveShift {
    0%   { transform: translate(0px, 0px); }
    50%  { transform: translate(7px, 1px); }
    100% { transform: translate(0px, 0px); }
  }

  .palms {
    animation: palmShift 5.5s ease-in-out infinite;
  }
  @keyframes palmShift {
    0%   { transform: translate(0px, 0px); }
    50%  { transform: translate(2px, -1px); }
    100% { transform: translate(0px, 0px); }
  }

  /* groggy blur state (applied to .world) */
  .groggy {
    filter: blur(6px) saturate(0.9) brightness(1.05);
    opacity: 0.92;
  }

  .clear {
    filter: blur(0px) saturate(1) brightness(1);
    opacity: 1;
    transition: filter 1400ms ease, opacity 1400ms ease;
  }

  /* vignette overlay, also directional via JS */
  .vignette {
    position: absolute;
    inset: 0;
    pointer-events: none;
    opacity: 0.65;
    transition: opacity 1200ms ease;
    background: radial-gradient(circle at 50% 50%,
      rgba(0,0,0,0) 38%,
      rgba(0,0,0,0.22) 68%,
      rgba(0,0,0,0.62) 100%);
    mix-blend-mode: multiply;
  }

  .vignette.clear {
    opacity: 0.18;
  }

  /* directional edge darkening, subtle but noticeable (level 5) */
  .edge {
    position: absolute;
    inset: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 800ms ease;
    mix-blend-mode: multiply;
  }

  /* left/right shading masks, opacity controlled in JS */
  .edge.left {
    background: linear-gradient(90deg,
      rgba(0,0,0,0.55) 0%,
      rgba(0,0,0,0.18) 26%,
      rgba(0,0,0,0.0) 55%);
  }

  .edge.right {
    background: linear-gradient(270deg,
      rgba(0,0,0,0.55) 0%,
      rgba(0,0,0,0.18) 26%,
      rgba(0,0,0,0.0) 55%);
  }

  /* eyelids overlay */
  .eyelids {
    position: absolute;
    inset: 0;
    z-index: 50;
    pointer-events: none;
    overflow: hidden;
    --pct: 0%;
    --dur: 650ms;
  }

  .eyelid {
    position: absolute;
    left: 0;
    width: 100%;
    height: 50%;
    background: #000;
    transition: transform var(--dur) cubic-bezier(0.33,0,0.2,1);
  }

  .eyelid.top {
    top: 0;
    transform: translateY(calc(-1 * var(--pct)));
  }

  .eyelid.bottom {
    bottom: 0;
    transform: translateY(var(--pct));
  }

  .eyelids.closed { --pct: 0%; }
  .eyelids.open1  { --pct: 52%; }
  .eyelids.open2  { --pct: 100%; }

  /* make it fit any screen while preserving aspect */
  .fit {
    transform: scale(var(--s));
    transform-origin: center center;
  }
</style>
</head>

<body>
<div class="app">
  <div class="scene fit" id="scene">

    <!-- WORLD (moves + blurs) -->
    <div class="world groggy" id="world">
      <img src="island_base.png" class="base" alt="">
      <img src="water_overlay.png" class="water" alt="">
      <img src="palm_overlay.png" class="palms" alt="">
    </div>

    <!-- VIGNETTE + DIRECTIONAL EDGES -->
    <div class="vignette" id="vignette"></div>
    <div class="edge left" id="edgeLeft"></div>
    <div class="edge right" id="edgeRight"></div>

    <!-- EYELIDS -->
    <div class="eyelids closed" id="eyelids">
      <div class="eyelid top"></div>
      <div class="eyelid bottom"></div>
    </div>

  </div>
</div>

<script>
  /* lock scrolling */
  window.addEventListener("wheel", e => e.preventDefault(), { passive:false });
  window.addEventListener("touchmove", e => e.preventDefault(), { passive:false });
  window.addEventListener("keydown", e => {
    if (["ArrowUp","ArrowDown","Space","PageUp","PageDown"].includes(e.code)) e.preventDefault();
  });

  const scene = document.getElementById("scene");
  const world = document.getElementById("world");
  const vignette = document.getElementById("vignette");
  const edgeLeft = document.getElementById("edgeLeft");
  const edgeRight = document.getElementById("edgeRight");
  const eyelids = document.getElementById("eyelids");

  /* responsive scaling */
  function fit() {
    const w = 1200, h = 675;
    const s = Math.min(window.innerWidth / w, window.innerHeight / h);
    scene.style.setProperty("--s", s.toString());
  }
  window.addEventListener("resize", fit);
  fit();

  function setEyelids(state, dur) {
    eyelids.style.setProperty("--dur", dur + "ms");
    eyelids.classList.remove("closed","open1","open2");
    eyelids.classList.add(state);
  }

  /* PHASES (level 5, noticeable but tasteful)
     1) groggy "look up" drift while blurry
     2) settle to center as it clears
     3) gentle left-right scan after clear
     + directional vignette edges tied to x movement
  */

  let raf = null;
  let t0 = null;

  // movement state
  let x = 0, y = 0;
  let targetX = 0, targetY = 0;

  // scan params
  let scanning = false;
  let scanStart = 0;

  function applyWorld() {
    world.style.transform = `translate(${x.toFixed(2)}px, ${y.toFixed(2)}px)`;

    // directional edge shading based on x, stronger when scanning (level 5)
    const strength = Math.min(Math.abs(x) / 14, 1); // normalize to ~14px
    const edgeOpacity = scanning ? (0.22 + strength * 0.28) : (0.12 + strength * 0.18);

    if (x > 0.5) {
      edgeRight.style.opacity = edgeOpacity.toFixed(3);
      edgeLeft.style.opacity = "0";
    } else if (x < -0.5) {
      edgeLeft.style.opacity = edgeOpacity.toFixed(3);
      edgeRight.style.opacity = "0";
    } else {
      edgeLeft.style.opacity = "0";
      edgeRight.style.opacity = "0";
    }
  }

  function lerp(a, b, t) { return a + (b - a) * t; }

  function animate(now) {
    if (!t0) t0 = now;
    const t = now - t0;

    // Phase 1: groggy lift (0ms -> 2600ms)
    // move up (negative y) and a tiny drift right, no looping
    if (t < 2600) {
      const p = t / 2600;
      // ease out
      const e = 1 - Math.pow(1 - p, 3);
      targetY = lerp(18, -28, e);  // starts slightly down, lifts up
      targetX = lerp(-6, 10, e);   // tiny right drift
    }

    // Phase 2: settle to center (2600ms -> 4700ms)
    if (t >= 2600 && t < 4700) {
      const p = (t - 2600) / 2100;
      const e = 1 - Math.pow(1 - p, 3);
      targetX = lerp(targetX, 0, e);
      targetY = lerp(targetY, 0, e);
    }

    // Phase 3: horizon scan (starts at 4700ms)
    if (t >= 4700) {
      if (!scanning) {
        scanning = true;
        scanStart = now;
      }
      const st = (now - scanStart) / 1000; // seconds
      // big slow scan: 10px amplitude, 10s period
      const amp = 10;
      const period = 10;
      targetX = Math.sin((st * 2 * Math.PI) / period) * amp;
      // tiny vertical "breath"
      targetY = Math.sin((st * 2 * Math.PI) / (period * 1.6)) * 2;
    }

    // smooth follow (prevents jitter)
    x = lerp(x, targetX, 0.06);
    y = lerp(y, targetY, 0.06);

    applyWorld();
    raf = requestAnimationFrame(animate);
  }

  // start in groggy blur + strong vignette
  vignette.classList.remove("clear");
  world.classList.add("groggy");

  // TWO BLINKS, quicker
  // partial open -> close -> partial open -> close -> full open
  let tt = 350;
  setTimeout(() => setEyelids("open1", 600), tt); tt += 760;
  setTimeout(() => setEyelids("closed", 420), tt); tt += 620;
  setTimeout(() => setEyelids("open1", 560), tt); tt += 720;
  setTimeout(() => setEyelids("closed", 420), tt); tt += 600;
  setTimeout(() => setEyelids("open2", 920), tt);

  // kick off motion immediately (during blur)
  raf = requestAnimationFrame(animate);

  // clear blur gradually shortly after final open begins
  setTimeout(() => {
    world.classList.remove("groggy");
    world.classList.add("clear");
    vignette.classList.add("clear");
  }, tt + 180);

</script>
</body>
</html>
